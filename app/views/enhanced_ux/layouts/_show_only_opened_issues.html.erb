<!--
// Path pattern:       /((issues|versions)/[0-9]+|roadmap)
// Project pattern:
// Insertion position: Head of all pages
// Type:               HTML
// Comment:            Show only opened issues
-->
<script>
  var setupShowOnlyOpenedIssues = undefined;

  //<![CDATA[
  window.addEventListener("DOMContentLoaded", function () {
    // ----- settings start -----
    const issueHiddenDefault = true;
    // ----- settings end -----

    const resourcesAll = {
      en: { labelHideClosed: "Hide closed issues" },
      ja: { labelHideClosed: "完了したチケットを隠す" },
    };
    const resources =
      resourcesAll[document.documentElement.lang] || resourcesAll["en"];

    const pageTypes = {
      issues: /\/issues\/[0-9]+$/,
      roadmap: /\/roadmap$/,
      versions: /\/versions\/[0-9]+$/,
    };
    const pageType = Object.keys(pageTypes).find((key) =>
      pageTypes[key].test(location.pathname)
    );
    if (!pageType) return;

    const queries = {
      issues: {
        baseTarget: "#issue_tree, #relations",
        closest: "#issue_tree, #relations",
        table: "table.list.issues",
        checkBoxAppendTarget: "div.contextual+p:first",
      },
      roadmap: {
        baseTarget: "#roadmap>form, article.version-article>form",
        closest: null,
        table: "table.list.related-issues",
        checkBoxAppendTarget: "table.list>caption",
      },
      versions: {
        baseTarget: "#roadmap>form, article.version-article>form",
        closest: null,
        table: "table.list.related-issues",
        checkBoxAppendTarget: "table.list>caption",
      },
    }[pageType];

    const configs = {
      issues: {
        replaceTrWithDiv: false,
      },
      roadmap: {
        replaceTrWithDiv: true,
      },
      versions: {
        replaceTrWithDiv: true,
      },
    }[pageType];

    function findTable(target) {
      if (pageType === "issues") {
        return $(target).closest(queries.closest).find(queries.table);
      } else {
        const $table = $(target).find(queries.table);
        if ($table.length > 0) {
          return $table;
        } else {
          return $(target).closest(queries.table);
        }
      }
    }

    if ($(queries.baseTarget).length == 0) return;

    function createCheckBox() {
      return $("<input>")
        .attr({
          type: "checkbox",
        })
        .prop("checked", issueHiddenDefault)
        .addClass("hide_closed_issue")
        .on("change", function () {
          const $table = findTable(this);
          toggleIssueView($table, this.checked);
        });
    }

    function toggleIssueView($table, hide = null) {
      hide = hide ?? !$table.hasClass("closed_issue_hidden");

      if (hide) {
        $table.find("tr.issue.closed").addClass("hidden");

        if (configs.replaceTrWithDiv) {
          // Replace TR to DIV
          $table.replaceWith(function () {
            return $("<div>")
              .append($(this).contents())
              .addClass($(this).attr("class"));
          });
        }
      } else {
        if (configs.replaceTrWithDiv) {
          // Replace DIV to TR
          $table.find("div.issue.hidden").replaceWith(function () {
            return $("<tr>")
              .append($(this).contents())
              .addClass($(this).attr("class"));
          });
        }

        $table.find("tr.issue").removeClass("hidden");
      }
      $table.toggleClass("closed_issue_hidden", hide);
    }

    function setupCheckBox(targetElement) {
      const $table = findTable(targetElement);

      if (
        $(targetElement)
          .find(queries.checkBoxAppendTarget)
          .find("input.hide_closed_issue").length === 0
      ) {
        // Exit if there are no items
        if ($table.length === 0) return;

        // Exit if all issue is opened or closed
        const count_all = $table.find("tr.issue").length;
        const count_closed = $table.find("tr.issue.closed").length;
        if (count_closed === 0 || count_all === count_closed) return;

        // Add CheckBox
        $(targetElement)
          .find(queries.checkBoxAppendTarget)
          .append(
            $("<span/>")
              .addClass("hide_closed_issue_button_outer")
              .append(
                $("<label>")
                  .text(resources.labelHideClosed)
                  .prepend(createCheckBox())
              )
          );

        setDefaultState($table);
      }

      restoreState($table);
    }

    function setDefaultState($table) {
      toggleIssueView($table, issueHiddenDefault);
    }

    function restoreState($table) {
      toggleIssueView($table, $table.hasClass("closed_issue_hidden"));
    }

    setupShowOnlyOpenedIssues = function () {
      $(queries.baseTarget).each((_, targetElement) => {
        if (
          $(targetElement)
            .find(queries.checkBoxAppendTarget)
            .find("input.hide_closed_issue").length === 0
        ) {
          setupCheckBox(targetElement);

          new MutationObserver((mutationList, observer) => {
            for (const mutation of mutationList) {
              setupCheckBox(targetElement);
            }
          }).observe(targetElement, {
            childList: true,
          });
        }
      });
    };

    /**
     * Set up form change detection.
     * This method's purpose is to detect when the issue view is replaced by
     * other plugins like Redmine RT.
     */
    function setupFormChangeDetection() {
      const targetNode = $("div.issue.details").parent()[0];

      if (targetNode) {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "childList") {
              mutation.addedNodes.forEach((node) => {
                if (
                  node.nodeType === Node.ELEMENT_NODE &&
                  $(node).is("div.issue.details")
                ) {
                  setupShowOnlyOpenedIssues();
                }
              });
            }
          });
        });

        observer.observe(targetNode, {
          childList: true,
          subtree: true,
          attributes: false,
        });
      }
    }

    // Initial invoke
    setupShowOnlyOpenedIssues();

    // Set up form change detection
    setupFormChangeDetection();
  });
  //]]>
</script>

<style>
  :is(#issue_tree, #relations) {
    label:has(input.hide_closed_issue) {
      margin-left: 0px;
      font-size: 0.8em;
      cursor: pointer;
    }
    input.hide_closed_issue {
      width: 0.8em;
      margin-left: 5px;
      cursor: pointer;
    }

    table.list.issues.closed_issue_hidden .issue.hidden {
      display: none !important;
    }
  }

  #roadmap table.list.related-issues {
    span.hide_closed_issue_button_outer {
      float: right;

      label {
        margin-left: 5px;
        font-size: 0.9em;
        cursor: pointer;
      }
      input.hide_closed_issue {
        width: 0.9em;
        cursor: pointer;
      }
    }
    & > tbody {
      & > :is(tr.hidden, span.hidden) {
        display: none;
      }
      & > :is(tr.even, tr.issue.hascontextmenu:nth-of-type(even)) {
        background-color: #fff;
      }
      & > :is(tr.odd, tr.issue.hascontextmenu:nth-of-type(odd)) {
        background-color: #f6f7f8;
      }
    }
  }
</style>
